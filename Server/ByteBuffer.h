#ifndef BYTEBUFFER_H
#define BYTEBUFFER_H

#include <QByteArray>

/**
 * @brief The ByteBuffer class - класс, представляющий собой обёртку
 * над библиотечным QByteArray и расширяет его функционал для
 * удобной записи и чтения данных в QByteArray
 *
 * Вроде как в Qt есть библиотечные QDataStream, выполняющий
 * аналогичные решения, но менее точные и удобные с точки зрения
 * использования
 */
class ByteBuffer : public QByteArray {

    protected:
        /**
         * @brief index - позиция чтения в буфере.
         * Каждый раз, когда мы читаем что-то,
         * индекс увеличивается на количество
         * прочитанных байт
         */
        qint32 position;

    public:
        /**
         * @brief ByteBuffer - базовый конструктор
         */
        ByteBuffer();
        /**
         * @brief ByteBuffer - конструктор с указанием размера буфера
         * Но вообще, на методы записи он вроде как сам расширяется
         * @param size - размер требуемого буфера
         */
        explicit ByteBuffer(quint32 size);
        /**
         * @brief ByteBuffer - конструктор копирования по сути,
         * хоть для С++ он таким не является по синтаксису
         * @param other - второй буффер
         */
        explicit ByteBuffer(QByteArray other);
        /**
         * @brief ByteBuffer - конструктор для строк, чтобы
         * можно было сразу сделать буфер из строчки
         * Я не понимаю почему этого нет в QByteArray
         * @param buffer - строка текста с данными
         */
        explicit ByteBuffer(QString buffer);
        /**
         * @brief ByteBuffer - конструктор копирования, который
         * является синтаксически таковым для компилятора
         * @param other - объект, который надо скопировать
         */
        ByteBuffer(ByteBuffer & other);

//**********************************************************************************************
//********************************              ************************************************
//********************************    Чтение    ************************************************
//********************************              ************************************************
//**********************************************************************************************

        /**
         * @brief readByte - чтение одного байта из буфера;
         * Сдвигает индекс чтения буффера на 1 позицию;
         * Нет разницы LE или BE, он же байт :\
         * @return
         */
        quint8 readByte();
        /**
         * @brief readIntLE - чтение 4-х байт из буфера;
         * Сдвигает индекс чтения буффера на 4-ую позицию;
         * Читает в формате LittleEndian
         * @return
         */
        qint32 readIntLE();
        /**
         * @brief readLongLE - чтение 8-ми байт из буфера;
         * Сдвигает индекс чтения буффера на 8-ую позицию;
         * Читает в формате LittleEndian
         * @return
         */
        qint64 readLongLE();
        /**
         * @brief readShortLE - чтение 2-х байт из буфера;
         * Сдвигает индекс чтения буффера на 2-ую позицию;
         * Читает в формате LittleEndian
         * @return
         */
        qint16 readShortLE();
        /**
         * @brief readIntBE - чтение 4-х байт из буфера;
         * Сдвигает индекс чтения буффера на 4-ую позицию;
         * Читает в формате BigEndian
         * @return
         */
        qint32 readIntBE();
        /**
         * @brief readLongBE - чтение 8-ми байт из буфера;
         * сдвигает индекс чтения буффера на 8-ую позицию;
         * Читает в формате BigEndian
         * @return
         */
        qint64 readLongBE();
        /**
         * @brief readShortBE - чление 2-х байт из буфера;
         * сдвигает индекс чтения буффера на 4-ую позицию;
         * Читает в формате BigEndian
         * @return
         */
        qint16 readShortBE();
        /**
         * @brief read - читает указанное количество байт и возвращает
         * их как объект QByteArray (UP: может возвращать ByteBuffer?)
         * @param lenght - длина зоны, которую можно прочитать
         * @return
         */
        QByteArray read(qint32 lenght);
        /**
         * @brief readEnd - читает весь оставшийся буффер и возвращает
         * его как объект QByteArray (UP: может возвращать ByteBuffer?)
         * @return
         */
        QByteArray readEnd();

//**********************************************************************************************
//********************************              ************************************************
//********************************    Запись    ************************************************
//********************************              ************************************************
//**********************************************************************************************

        /**
         * @brief writeByte записывает байт в конец буфера
         * @param num - значение
         * @return обновлённый буфер
         */
        ByteBuffer writeByte(qint8 num);
        /**
         * @brief writeIntLE записывает 4 байта в конец буфера
         * в формате LittleEndian
         * @param num - значение
         * @return обновлённый буфер
         */
        ByteBuffer writeIntLE(qint32 num);
        /**
         * @brief writeLongLE записывает 8 байт в конец буфера
         * в формате LittleEndian
         * @param num - значение
         * @return обновлённый буфер
         */
        ByteBuffer writeLongLE(qint64 num);
        /**
         * @brief writeShortLE записывает 2 байта в конец буфера
         * в формате LittleEndian
         * @param num - значение
         * @return обновлённый буфер
         */
        ByteBuffer writeShortLE(qint16 num);
        /**
         * @brief writeIntBE записывает 4 байта в конец буфера
         * в формате BigEndian
         * @param num - значение
         * @return обновлённый буфер
         */
        ByteBuffer writeIntBE(qint32 num);
        /**
         * @brief writeLongBE записывает 8 байт в конец буфера
         * в формате BigEndian
         * @param num - значение
         * @return обновлённый буфер
         */
        ByteBuffer writeLongBE(qint64 num);
        /**
         * @brief writeShortBE записывает 2 байта в конец буфера
         * в формате BigEndian
         * @param num - значение
         * @return обновлённый буфер
         */
        ByteBuffer writeShortBE(qint16 num);
        /**
         * @brief write записывает буфер в конец текущего буфера
         * по сути конкатенация буферов
         * @param buf - буфер, который следует дописать в конец
         * @return склеенный буфер
         */
        ByteBuffer write(QByteArray buf);

//**********************************************************************************************
//********************************              ************************************************
//********************************  Служебное   ************************************************
//********************************              ************************************************
//**********************************************************************************************

        /**
         * @brief isEnd - проверяет, можно ли ещё читать байты
         * @return true - если больше нельзя читать буфер
         *          false если буфер ещё не закончился
         */
        bool isEnd();
        /**
         * @brief flushIndex - сбрасывает индекс чтения на 0,
         * что позволяет читать буфер с самого начала
         * @return
         */
        void flushIndex();
        /**
         * @brief clear - сбрасывает содержимое и индексы
         * буфера в исходное состояние
         */
        void clear();
        /**
         * @brief getAvailableBytes - возвращет количество
         * доступных для чтения байт
         * @return
         */
        quint32 getAvailableBytes();


};

char* byteToHex(QByteArray b);      // в протоколе удобнее анализировать команды, разбитые на байты и по восемь в строке
QString byteToHexS(QByteArray b);   // чтобы можно было привести протокол к наглядному виду

#endif // BYTEBUFFER_H
